package lyc.compiler;

import java_cup.runtime.*;
import lyc.compiler.ParserSym; 
import lyc.compiler.files.IntermediateCodeGenerator;
import java.util.Stack;
import java.util.List;
import java.util.ArrayList;
import java.util.Arrays;

class Parser;

parser code {:
    // Esta pila es para el backpatching, guarda los saltos a rellenar.
    private java.util.Stack<Integer> jumpToPatch = new java.util.Stack<>();

    // Helper: Devuelve el "puntero" de la próxima instrucción.
    private int getNextIndex() {
        return IntermediateCodeGenerator.getInstance().getInstructionCount();
    }

    // Helper: Mete un "_PLHDR" y nos da su índice.
    private int generatePlaceholder() {
        return IntermediateCodeGenerator.getInstance().addToken("_PLHDR");
    }

    // Rellena el lugar (indexToPatch) con el destino (targetIndex).
    private void backpatch(int indexToPatch, int targetIndex) {
        IntermediateCodeGenerator.getInstance().backpatch(indexToPatch, String.valueOf(targetIndex));
    }

    // Invierte la lógica (ej: BGT -> BLE).
    private String invertJump(String jumpType) {
        switch(jumpType) {
            case "BLE": return "BGT"; // >  ->  <=
            case "BGT": return "BLE"; // <= ->  >
            case "BGE": return "BLT"; // <  ->  >=
            case "BLT": return "BGE"; // >= ->  <
            case "BNE": return "BEQ"; // =  ->  !=
            case "BEQ": return "BNE"; // != ->  =
            default: return jumpType; // Dejarlo como está si no se reconoce
        }
    }
:};

// Terminals
terminal INIT;
terminal ASSIG;
terminal PLUS;
terminal SUB;
terminal MULT;
terminal DIV;
terminal OPEN_BRACKET;
terminal CLOSE_BRACKET;
terminal OPEN_BRACE;
terminal CLOSE_BRACE;
terminal COMMA;
terminal COLON;
terminal INTEGER_CONSTANT;
terminal IDENTIFIER;
terminal READ;
terminal WRITE;
terminal TEXT;
terminal COMMENT;
terminal FLOAT_CONSTANT;
terminal TYPE_INT;
terminal TYPE_FLOAT;
terminal TYPE_STRING;
terminal GT;
terminal LT;
terminal GE;
terminal LE;
terminal EQ;
terminal AND;
terminal OR;
terminal NOT;
terminal OPEN_SQUARE;
terminal CLOSE_SQUARE;
terminal SEMICOLON;
terminal IF;
terminal ELSE;
terminal WHILE;
terminal IS_ZERO;
terminal TRIANGLE_AREA_MAXIMUM;

// Non Terminals
non terminal program;
non terminal sentence_list;
non terminal sentence;
non terminal assignment;
non terminal String expression;
non terminal String term;
non terminal String factor;
non terminal read;
non terminal write;

non terminal init_block;
non terminal decl_list;
non terminal declaration;
non terminal java.util.List id_list;
non terminal typeDef;


//Funcion triangle
non terminal arg_list;
non terminal java.util.List triangle;
non terminal java.util.List coords;

non terminal while_statement;
non terminal if_statement;

non terminal java.util.List<Integer> if_header;

non terminal java.util.List while_header;
non terminal java.util.List<Integer> condition;

non terminal Integer while_start;

non terminal String simple_condition; 

non terminal Integer marker_M;



non terminal java.util.List or_intermediate;


// PRECEDENCIA PARA OPERADORES LÓGICOS
// Resuelve conflictos Shift/Reduce y Reduce/Reduce.
precedence left OR;
precedence left AND;
precedence left NOT;


// --- REGLAS DE LA GRAMÁTICA ---

start with program;

// REGLA MARCADORA (M): No genera token, solo "marca" el índice actual.
marker_M ::= {: RESULT = getNextIndex(); :};

program ::= init_block sentence_list | init_block;

sentence_list ::= sentence_list sentence | sentence;

sentence ::= assignment {: System.out.println("Assignment"); :};
sentence ::= read {: System.out.println("Sentence = READ"); :};
sentence ::= write {: System.out.println("Sentence = WRITE"); :};
sentence ::= if_statement {: System.out.println("Sentence = IF"); :};
sentence ::= while_statement {: System.out.println("Sentence = WHILE"); :};
sentence ::= COMMENT {: System.out.println("comentario"); :};

// --- ESTRUCTURAS DE CONTROL ---


// IF HEADER
if_header ::= IF OPEN_BRACKET condition:c_falseList CLOSE_BRACKET
            {:
                // 'condition' ya generó los saltos y sus _PLHDR.
                // c_falseList tiene los índices de esos lugares.
                // Solo pasamos la lista de saltos falsos para arriba.
                RESULT = c_falseList;
            :};

// IF SIMPLE
if_statement ::= if_header:falseList OPEN_BRACE marker_M:inicio_cuerpo sentence_list CLOSE_BRACE
                {:
                    System.out.println("IF");
                    // 1. Obtenemos la lista de huecos a rellenar
                    java.util.List<Integer> placeholders = (java.util.List<Integer>) falseList;

                    // 2. 'inicio_cuerpo' es donde arranca el { ... }
                    // 3. 'fin_if_pos' es la próxima instrucción (afuera del IF).
                    int fin_if_pos = getNextIndex();

                    // 4. Rellenamos los huecos.
                    for(int placeholder : placeholders) {
                        if (placeholder < 0) {
                            // (Caso OR) Índice negativo: es un "salto verdadero", va al 'inicio_cuerpo'.
                            backpatch(-placeholder, inicio_cuerpo);
                        } else {
                            // Índice positivo: es un "salto falso", va al 'fin_if_pos'.
                            backpatch(placeholder, fin_if_pos);
                        }
                    }
                :};

// IF-ELSE
if_statement ::= if_header:falseList OPEN_BRACE marker_M:inicio_then sentence_list:then_part CLOSE_BRACE
                {:
                    System.out.println("IF-ELSE - Final del THEN");
                    // Obtenemos la "false list" (que ahora salta al ELSE).
                    java.util.List<Integer> placeholders_sino = (java.util.List<Integer>) falseList;

                    // 1. Generamos el "BI" (salto incondicional) para esquivar el ELSE.
                    IntermediateCodeGenerator.getInstance().addToken("BI");

                    // 2. Creamos un hueco para este BI.
                    int fin_if_placeholder = generatePlaceholder();

                    // 3. El inicio del ELSE es la instrucción que sigue.
                    int else_start_pos = getNextIndex();

                    // 4. Rellenamos los huecos de la condición.
                    for(int placeholder : placeholders_sino) {
                        if (placeholder < 0) {
                            // (Caso OR) Índice negativo: "salto verdadero", va al inicio del THEN.
                            backpatch(-placeholder, inicio_then);
                        } else {
                            // Índice positivo: "salto falso", debe ir al ELSE.
                            backpatch(placeholder, else_start_pos);
                        }
                    }

                    // 5. Devolvemos el hueco del "BI" para que se rellene al final.
                    RESULT = java.util.Arrays.asList(fin_if_placeholder);
                :}
                ELSE OPEN_BRACE sentence_list:else_part CLOSE_BRACE
                {:
                    System.out.println("IF-ELSE - Final del ELSE");
                    
                    // Recuperamos el hueco del BI que saltará al final.
                    int fin_if_placeholder = ((java.util.List<Integer>)RESULT).get(0);

                    // El destino final es la instrucción que sigue.
                    int fin_if_pos = getNextIndex();

                    // 5. Rellenamos el hueco del BI con el destino final.
                    backpatch(fin_if_placeholder, fin_if_pos);
                :};

/* while ( condition ) { sentence_list } */

while_start ::= WHILE OPEN_BRACKET
                {:
                    System.out.println("WHILE - Inicio");
                    int inicio_pos = getNextIndex();
                    // Devuelve el índice donde empieza la condición (para el loop).
                    RESULT = inicio_pos; 
                :};

while_header ::= while_start:inicio_pos condition:c_falseList CLOSE_BRACKET
                {:
                    // 'condition' ya generó los saltos falsos (falseList)
                    // Pasamos dos cosas hacia arriba:
                    // inicio_pos y c_falseList
                    java.util.List<Object> resultList = new java.util.ArrayList<>();
                    resultList.add(inicio_pos);
                    resultList.add(c_falseList);
                    RESULT = resultList;
                :};

while_statement ::= while_header:header_info OPEN_BRACE marker_M:inicio_cuerpo sentence_list:body CLOSE_BRACE
                {:
                    // Desempaquetamos la información
                    java.util.List info = (java.util.List) header_info;
                    int inicio_pos = (Integer) info.get(0);
                    java.util.List<Integer> falseList = (java.util.List<Integer>) info.get(1);

                    // 1. Generamos el "BI" para volver al inicio (loop).
                    IntermediateCodeGenerator.getInstance().addToken("BI");
                    // 2. Ponemos el destino (inicio_pos) ahí mismo. No hace falta hueco.
                    IntermediateCodeGenerator.getInstance().addToken(String.valueOf(inicio_pos));

                    // 3. El destino final (para los saltos falsos).
                    int fin_pos = getNextIndex();

                    // 4. Rellenamos los huecos de la condición.
                    for(int placeholder : falseList) {
                        if (placeholder < 0) {
                            // Caso OR Índice negativo: salto verdadero, va al inicio del cuerpo.
                            backpatch(-placeholder, inicio_cuerpo);
                        } else {
                            // Índice positivo: salto falso, debe ir fuera del bucle.
                            backpatch(placeholder, fin_pos);
                        }
                    }
                :};


// --- CONDICIONES ---

// Caso Base: una simple_condition
condition ::= simple_condition:jumpType
            {:
                System.out.println("Condición simple");
                // 1. Emitir el salto (ej: "BLE").
                IntermediateCodeGenerator.getInstance().addToken(jumpType);
                
                // 2. Emitir el hueco ("_PLHDR") y guardar su índice.
                int placeholder = generatePlaceholder();
                
                // 3. Devolver una "false list" que contenga este hueco.
                java.util.List<Integer> falseList = new java.util.ArrayList<>();
                falseList.add(placeholder);
                RESULT = falseList;
            :};

// Lógica AND
condition ::= condition:c1 AND condition:c2
            {:
                System.out.println("Condicion AND");
                // Para AND, si c1 es F, salta; si c2 es F, salta.

                java.util.List<Integer> c1_falseList = (java.util.List<Integer>) c1;
                java.util.List<Integer> c2_falseList = (java.util.List<Integer>) c2;
                
                c1_falseList.addAll(c2_falseList); // Unimos las listas
                RESULT = c1_falseList; // Devolvemos la lista unida
            :};

// Lógica OR 
// Para OR necesitamos generar saltos cuando la condición es VERDADERA, no FALSA
or_intermediate ::= simple_condition:jumpType OR
                    {:
                        System.out.println("OR - Paso intermedio");
                        
                        // Para OR: invertimos el salto.
                        String trueJump = invertJump(jumpType);
                        
                        // Generar el salto VERDADERO (si c1 es V, salta al cuerpo).
                        IntermediateCodeGenerator.getInstance().addToken(trueJump);
                        int true_placeholder = generatePlaceholder();
                        
                        // Guardamos el hueco de este "salto verdadero".
                        java.util.List result = new java.util.ArrayList();
                        result.add(true_placeholder);
                        RESULT = result;
                    :};

// Paso 2: Evaluar c2 y devolver las listas correctas
condition ::= or_intermediate:inter condition:c2
            {:
                System.out.println("Condicion OR - Completando");
                
                // Desempaqueta la información del paso intermedio
                java.util.List info = (java.util.List) inter;
                int c1_true_placeholder = (Integer) info.get(0);
                java.util.List<Integer> c2_falseList = (java.util.List<Integer>) c2;
                
                // Solución: Devolvemos una lista especial:
                java.util.List<Integer> resultList = new java.util.ArrayList<>();
                // - Índice negativo: es un "salto verdadero" (va al cuerpo).
                resultList.add(-c1_true_placeholder); // Negativo = true jump
                // - Índices positivos: son "saltos falsos" (van afuera).
                resultList.addAll(c2_falseList);
                
                RESULT = resultList;
            :};

// Regla 'NOT' ahora invierte la lógica de salto
condition ::= NOT simple_condition:jumpType
            {:
                System.out.println("Condición NOT");
                
                // 1. Invertir el salto (ej: "BLE" -> "BGT").
                String invertedJump = invertJump(jumpType);

                // 2. Emitir el salto ya invertido.
                IntermediateCodeGenerator.getInstance().addToken(invertedJump);
                
                // 3. Emitir el hueco ("_PLHDR") y guardar su índice.
                int placeholder = generatePlaceholder();

                // 4. Devolver una "false list" que contenga este hueco.
                java.util.List<Integer> falseList = new java.util.ArrayList<>();
                falseList.add(placeholder);
                RESULT = falseList;
            :};


simple_condition ::= expression:e1 GT expression:e2
                    {:
                        System.out.println(">");
                        //VALIDACION Solo se pueden comparar numeros
                        if (!e1.equals("Int") && !e1.equals("Float")) {
                            throw new lyc.compiler.model.TypeMismatchException(
                                "Cannot apply '>' to non-numeric type '" + e1 + "'"
                            );
                        }
                        if (!e2.equals("Int") && !e2.equals("Float")) {
                            throw new lyc.compiler.model.TypeMismatchException(
                                "Cannot apply '>' to non-numeric type '" + e2 + "'"
                            );
                        }
                        IntermediateCodeGenerator.getInstance().addToken("CMP");
                        RESULT = "BLE"; // Devuelve el salto negado
                    :};

simple_condition ::= expression:e1 LT expression:e2
                    {:
                        System.out.println("<");
                        // VALIDACIONSolo se pueden comparar numeros
                        if (!e1.equals("Int") && !e1.equals("Float")) {
                            throw new lyc.compiler.model.TypeMismatchException(
                                "Cannot apply '<' to non-numeric type '" + e1 + "'"
                            );
                        }
                        if (!e2.equals("Int") && !e2.equals("Float")) {
                            throw new lyc.compiler.model.TypeMismatchException(
                                "Cannot apply '<' to non-numeric type '" + e2 + "'"
                            );
                        }
                        IntermediateCodeGenerator.getInstance().addToken("CMP");
                        RESULT = "BGE"; // Devuelve el salto negado
                    :};

simple_condition ::= expression:e1 GE expression:e2
                    {:
                        System.out.println(">=");
                        // VALIDACION Solo se pueden comparar numeros.
                        if (!e1.equals("Int") && !e1.equals("Float")) {
                            throw new lyc.compiler.model.TypeMismatchException(
                                "Cannot apply '>=' to non-numeric type '" + e1 + "'"
                            );
                        }
                        if (!e2.equals("Int") && !e2.equals("Float")) {
                            throw new lyc.compiler.model.TypeMismatchException(
                                "Cannot apply '>=' to non-numeric type '" + e2 + "'"
                            );
                        }
                        IntermediateCodeGenerator.getInstance().addToken("CMP");
                        RESULT = "BLT"; // Devuelve el salto *negado*
                    :};

simple_condition ::= expression:e1 LE expression:e2
                    {:
                        System.out.println("<=");
                        //VALIDACION: Solo se pueden comparar numeros
                        if (!e1.equals("Int") && !e1.equals("Float")) {
                            throw new lyc.compiler.model.TypeMismatchException(
                                "Cannot apply '<=' to non-numeric type '" + e1 + "'"
                            );
                        }
                        if (!e2.equals("Int") && !e2.equals("Float")) {
                            throw new lyc.compiler.model.TypeMismatchException(
                                "Cannot apply '<=' to non-numeric type '" + e2 + "'"
                            );
                        }
                        IntermediateCodeGenerator.getInstance().addToken("CMP");
                        RESULT = "BGT"; // Devuelve el salto negado
                    :};

simple_condition ::= expression:e1 EQ expression:e2
                    {:
                        System.out.println("=");
                        //VALIDACION: Tipos compatibles para '='.
                        boolean compatible = false;
                        
                        // Tipos idénticos: siempre compatible
                        if (e1.equals(e2)) {
                            compatible = true;
                        }
                        // Int y Float son compatibles entre sí para comparación
                        else if ((e1.equals("Int") || e1.equals("Float")) && 
                                (e2.equals("Int") || e2.equals("Float"))) {
                            compatible = true;
                        }
                        
                        if (!compatible) {
                            throw new lyc.compiler.model.TypeMismatchException(
                                "Cannot compare expression of type '" + e1 + 
                                "' with expression of type '" + e2 + "'"
                            );
                        }
                        
                        IntermediateCodeGenerator.getInstance().addToken("CMP");
                        RESULT = "BNE"; // Devuelve el salto negado
                    :};

simple_condition ::= IS_ZERO OPEN_BRACKET expression:exp CLOSE_BRACKET
                    {:
                        System.out.println("IS_ZERO_CONDITION");
                        // VALIDACIÓN: 'isZero' solo aplica a numeros
                        if (!exp.equals("Int") && !exp.equals("Float")) {
                            throw new lyc.compiler.model.TypeMismatchException(
                                "Cannot apply 'isZero' to non-numeric type '" + exp + "'"
                            );
                        }
                        IntermediateCodeGenerator.getInstance().addToken("0");
                        IntermediateCodeGenerator.getInstance().addToken("CMP");
                        RESULT = "BNE"; // Salta si NO es cero
                    :};


// --- TIPOS DE DATOS ---

typeDef ::= TYPE_INT    {: RESULT = "Int"; :};
typeDef ::= TYPE_FLOAT  {: RESULT = "Float"; :};
typeDef ::= TYPE_STRING {: RESULT = "String"; :};


// DECLARACIONES 

init_block ::= INIT OPEN_BRACE decl_list CLOSE_BRACE {: System.out.println("Init block cerrado"); :};

decl_list ::= decl_list declaration;
decl_list ::= declaration;

// una declaración puede tener varias variables separadas por coma
declaration ::= id_list:l COLON typeDef:td
                {:
                    System.out.println("Declaracion de variables tipo " + td);
                    lyc.compiler.files.SymbolTableGenerator.getInstance().addIdentifiers(l, (String) td);
                :};

id_list ::= id_list:l COMMA IDENTIFIER:id
            {:
                l.add(id);
                RESULT = l;
                System.out.println("Variable: " + id);
            :};

id_list ::= IDENTIFIER:id
            {:
                java.util.List l = new java.util.ArrayList();
                l.add(id);
                RESULT = l;
                System.out.println("Variable: " + id);
            :};


// --- ASIGNACIÓN Y EXPRESIONES ARITMÉTICAS ---

assignment ::= IDENTIFIER:id ASSIG expression:exprType
            {:
            System.out.println("Assignment");
            // VALIDACIÓN: Verificar que la variable esté declarada
            if (!lyc.compiler.files.SymbolTableGenerator.getInstance().isVariableDeclared(id.toString())) {
                throw new lyc.compiler.model.UnknownVariableException("Variable '" + id + "' no fue declarada");
            }
            
            // VALIDACIÓN: Verificar compatibilidad de tipos
            String variableType = lyc.compiler.files.SymbolTableGenerator.getInstance().getVariableType(id.toString());
            System.out.println("Validando tipo de variable: " + variableType + " con expresion de tipo: " + exprType);
            
            if (variableType != null && exprType != null) {
                // Reglas de compatibilidad:
                // 1. Tipos exactos deben coincidir (Int = Int, String = String)
                // 2. Int puede asignarse a Float 
                boolean compatible = false;
                
                if (variableType.equals(exprType)) {
                    // Tipos idénticos: siempre compatible
                    compatible = true;
                } else if (variableType.equals("Float") && exprType.equals("Int")) {
                    // Int puede asignarse a Float (promoción)
                    compatible = true;
                }
                
                if (!compatible) {
                    throw new lyc.compiler.model.TypeMismatchException(
                        "Cannot assign expression of type '" + exprType + "' to variable '" + 
                        id + "' of type '" + variableType + "'"
                    );
                }
            }
            
            IntermediateCodeGenerator.getInstance().addToken(id.toString());
            IntermediateCodeGenerator.getInstance().addToken(":=");
            :};

expression ::= expression:e PLUS term:t
            {:
            System.out.println("+");
            IntermediateCodeGenerator.getInstance().addToken("+");
            // Validar que ambos sean números.
            if (!e.equals("Int") && !e.equals("Float")) {
                throw new lyc.compiler.model.TypeMismatchException("Cannot apply '+' to non-numeric type '" + e + "'");
            }
            if (!t.equals("Int") && !t.equals("Float")) {
                throw new lyc.compiler.model.TypeMismatchException("Cannot apply '+' to non-numeric type '" + t + "'");
            }
            // Si alguno es Float, el resultado es Float
            RESULT = (e.equals("Float") || t.equals("Float")) ? "Float" : "Int";
            :};
            
expression ::= expression:e SUB term:t
            {:
            System.out.println("-");
            IntermediateCodeGenerator.getInstance().addToken("-");
            // Validar que ambos sean números.
            if (!e.equals("Int") && !e.equals("Float")) {
                throw new lyc.compiler.model.TypeMismatchException("Cannot apply '-' to non-numeric type '" + e + "'");
            }
            if (!t.equals("Int") && !t.equals("Float")) {
                throw new lyc.compiler.model.TypeMismatchException("Cannot apply '-' to non-numeric type '" + t + "'");
            }
            // Si alguno es Float, el resultado es Float
            RESULT = (e.equals("Float") || t.equals("Float")) ? "Float" : "Int";
            :};

expression ::= term:t 
            {: 
            System.out.println("Expression = Term");
            RESULT = t;
            :};

term ::= term:t MULT factor:f
    {:
    System.out.println("*");
    IntermediateCodeGenerator.getInstance().addToken("*");
    // Validar que ambos sean números.
    if (!t.equals("Int") && !t.equals("Float")) {
        throw new lyc.compiler.model.TypeMismatchException("Cannot apply '*' to non-numeric type '" + t + "'");
    }
    if (!f.equals("Int") && !f.equals("Float")) {
        throw new lyc.compiler.model.TypeMismatchException("Cannot apply '*' to non-numeric type '" + f + "'");
    }
    // Si alguno es Float, el resultado es Float
    RESULT = (t.equals("Float") || f.equals("Float")) ? "Float" : "Int";
    :};

term ::= term:t DIV factor:f
    {:
    System.out.println("/");
    IntermediateCodeGenerator.getInstance().addToken("/");
    // Validar que ambos sean números.
    if (!t.equals("Int") && !t.equals("Float")) {
        throw new lyc.compiler.model.TypeMismatchException("Cannot apply '/' to non-numeric type '" + t + "'");
    }
    if (!f.equals("Int") && !f.equals("Float")) {
        throw new lyc.compiler.model.TypeMismatchException("Cannot apply '/' to non-numeric type '" + f + "'");
    }
    // Si alguno es Float, el resultado es Float
    RESULT = (t.equals("Float") || f.equals("Float")) ? "Float" : "Int";
    :};

term ::= factor:f 
    {: 
    System.out.println("Term = factor");
    RESULT = f;
    :};

factor ::= IDENTIFIER:id
        {:
        System.out.println("Id: " + id);
        IntermediateCodeGenerator.getInstance().addToken(id.toString());
        // Obtener el tipo de la variable desde la tabla de símbolos
        String idType = lyc.compiler.files.SymbolTableGenerator.getInstance().getVariableType(id.toString());
        if (idType == null) {
            throw new lyc.compiler.model.UnknownVariableException("Variable '" + id + "' no fue declarada");
        }
        RESULT = idType;
        :};
        
factor ::= INTEGER_CONSTANT:int_const
        {:
        System.out.println("Integer: " + int_const );
        IntermediateCodeGenerator.getInstance().addToken(int_const.toString());
        RESULT = "Int";
        :};

factor ::= FLOAT_CONSTANT:float_const
        {:
        System.out.println("Float: " + float_const );
        IntermediateCodeGenerator.getInstance().addToken(float_const.toString());
        RESULT = "Float";
        :};

factor ::= TEXT:string_const
        {:
        System.out.println("String: " + string_const);
        IntermediateCodeGenerator.getInstance().addToken(string_const.toString());
        RESULT = "String";
        :};

factor ::= OPEN_BRACKET expression:e CLOSE_BRACKET 
        {: 
        System.out.println("Factor = (Expression)");
        RESULT = e;
        :};
        
factor ::= TRIANGLE_AREA_MAXIMUM OPEN_BRACKET arg_list CLOSE_BRACKET
        {:
        System.out.println("Funcion triangle - metodo");
    
        :};

/* Unarios (para -n, +n) */
factor ::= PLUS factor:f 
        {:
        System.out.println("unario +");
        IntermediateCodeGenerator.getInstance().addToken("+");
        if (!f.equals("Int") && !f.equals("Float")) {
            throw new lyc.compiler.model.TypeMismatchException("Cannot apply unary '+' to non-numeric type '" + f + "'");
        }
        RESULT = f;
        :};
        
factor ::= SUB factor:f 
        {:
        System.out.println("unario -");
        IntermediateCodeGenerator.getInstance().addToken("-");
        if (!f.equals("Int") && !f.equals("Float")) {
            throw new lyc.compiler.model.TypeMismatchException("Cannot apply unary '-' to non-numeric type '" + f + "'");
        }
        RESULT = f;
        :};


read    ::= READ OPEN_BRACKET IDENTIFIER:id CLOSE_BRACKET
        {:
        System.out.println("READ");
        IntermediateCodeGenerator.getInstance().addToken(id.toString());
        IntermediateCodeGenerator.getInstance().addToken("READ");
        :};

write   ::= WRITE OPEN_BRACKET IDENTIFIER:id CLOSE_BRACKET
        {:
        System.out.println("WRITE");
        IntermediateCodeGenerator.getInstance().addToken(id.toString());
        IntermediateCodeGenerator.getInstance().addToken("WRITE");
        :};

write   ::= WRITE OPEN_BRACKET TEXT:text CLOSE_BRACKET
        {:
        System.out.println("WRITE");
        IntermediateCodeGenerator.getInstance().addToken(text.toString());
        IntermediateCodeGenerator.getInstance().addToken("WRITE");
        :};

//Funcion triangle

/* COORDS */
coords ::= expression:x COMMA expression:y
    {:
        System.out.println("Coordenada procesada");
        // VALIDACIÓN: las coordenadas deben ser numéricas.
        if (!x.equals("Int") && !x.equals("Float")) {
            throw new lyc.compiler.model.TypeMismatchException(
                "Cannot use non-numeric type '" + x + "' as triangle coordinate"
            );
        }
        if (!y.equals("Int") && !y.equals("Float")) {
            throw new lyc.compiler.model.TypeMismatchException(
                "Cannot use non-numeric type '" + y + "' as triangle coordinate"
            );
        }

        // Devolvemos los tipos (por si acaso).
        java.util.List<String> coordTypes = new java.util.ArrayList<>();
        coordTypes.add(x);
        coordTypes.add(y);
        RESULT = coordTypes;
    :};

/*TRIANGLE
   No emitimos tokens. Las expresiones (x1, y1...) ya están en la polaca.
   Solo agrupamos los tipos.
*/
triangle ::= OPEN_SQUARE coords:c1 SEMICOLON coords:c2 SEMICOLON coords:c3 CLOSE_SQUARE
    {:
        System.out.println("Triangulo con 3 coordenadas (parseado)");
        java.util.List<java.util.List<String>> triangleTypes = new java.util.ArrayList<>();
        triangleTypes.add((java.util.List<String>) c1);
        triangleTypes.add((java.util.List<String>) c2);
        triangleTypes.add((java.util.List<String>) c3);
        RESULT = triangleTypes;
    :};

/* ARG_LIST */
arg_list ::= triangle:t1 SEMICOLON triangle:t2
    {:
        System.out.println("TRIANGLE_AREA_MAXIMUM");

        IntermediateCodeGenerator gen = IntermediateCodeGenerator.getInstance();

        // --- TRIÁNGULO 1
        String tx1 = "t_x1_1"; String ty1 = "t_y1_1";
        String tx2 = "t_x2_1"; String ty2 = "t_y2_1";
        String tx3 = "t_x3_1"; String ty3 = "t_y3_1";
        String area1 = "t_area_1";

        gen.addToken(ty3); gen.addToken(":="); 
        gen.addToken(tx3); gen.addToken(":="); 
        gen.addToken(ty2); gen.addToken(":="); 
        gen.addToken(tx2); gen.addToken(":="); 
        gen.addToken(ty1); gen.addToken(":="); 
        gen.addToken(tx1); gen.addToken(":="); 

        gen.addToken(tx1); gen.addToken(ty2); gen.addToken(ty3); gen.addToken("-"); gen.addToken("*");
        gen.addToken(tx2); gen.addToken(ty3); gen.addToken(ty1); gen.addToken("-"); gen.addToken("*");
        gen.addToken("+");
        gen.addToken(tx3); gen.addToken(ty1); gen.addToken(ty2); gen.addToken("-"); gen.addToken("*");
        gen.addToken("+");
        gen.addToken("0.5"); gen.addToken("*");
        gen.addToken(area1); gen.addToken(":=");

        // Absoluto area1
        gen.addToken(area1); gen.addToken("0"); gen.addToken("CMP");
        gen.addToken("BLT"); 
        int negPlaceholder = generatePlaceholder(); 
        // Backpatching local usando el índice actual
        IntermediateCodeGenerator.getInstance().backpatch(negPlaceholder, String.valueOf(IntermediateCodeGenerator.getInstance().getInstructionCount()));
        gen.addToken(area1); gen.addToken("-1"); gen.addToken("*");
        gen.addToken(area1); gen.addToken(":=");

        // --- TRIÁNGULO 2
        String ux1 = "t_x1_2"; String uy1 = "t_y1_2";
        String ux2 = "t_x2_2"; String uy2 = "t_y2_2";
        String ux3 = "t_x3_2"; String uy3 = "t_y3_2";
        String area2 = "t_area_2";

        gen.addToken(uy3); gen.addToken(":="); 
        gen.addToken(ux3); gen.addToken(":="); 
        gen.addToken(uy2); gen.addToken(":="); 
        gen.addToken(ux2); gen.addToken(":="); 
        gen.addToken(uy1); gen.addToken(":="); 
        gen.addToken(ux1); gen.addToken(":="); 

        gen.addToken(ux1); gen.addToken(uy2); gen.addToken(uy3); gen.addToken("-"); gen.addToken("*");
        gen.addToken(ux2); gen.addToken(uy3); gen.addToken(uy1); gen.addToken("-"); gen.addToken("*");
        gen.addToken("+");
        gen.addToken(ux3); gen.addToken(uy1); gen.addToken(uy2); gen.addToken("-"); gen.addToken("*");
        gen.addToken("+");
        gen.addToken("0.5"); gen.addToken("*");
        gen.addToken(area2); gen.addToken(":=");

        // Absoluto area2
        gen.addToken(area2); gen.addToken("0"); gen.addToken("CMP");
        gen.addToken("BLT");
        int negPlaceholder2 = generatePlaceholder();
        IntermediateCodeGenerator.getInstance().backpatch(negPlaceholder2, String.valueOf(IntermediateCodeGenerator.getInstance().getInstructionCount()));
        gen.addToken(area2); gen.addToken("-1"); gen.addToken("*");
        gen.addToken(area2); gen.addToken(":=");

        // --- MAX(area1, area2)
        String areaMax = "t_area_max";
        
        gen.addToken(area1); gen.addToken(area2); gen.addToken("CMP");
        gen.addToken("BGE"); // Saltar si area1 >= area2
        int truePlaceholder = generatePlaceholder();

        // ELSE: areaMax := area2
        gen.addToken(area2); gen.addToken(areaMax); gen.addToken(":=");

        gen.addToken("BI");
        int endPlaceholder = generatePlaceholder();

        // TRUE: areaMax := area1
        IntermediateCodeGenerator.getInstance().backpatch(truePlaceholder, String.valueOf(IntermediateCodeGenerator.getInstance().getInstructionCount()));
        gen.addToken(area1); gen.addToken(areaMax); gen.addToken(":=");

        IntermediateCodeGenerator.getInstance().backpatch(endPlaceholder, String.valueOf(IntermediateCodeGenerator.getInstance().getInstructionCount()));

        // !!! CORRECCIÓN IMPORTANTE !!!
        // Dejamos el resultado en la pila virtual de la Polaca.
        // Esto permite que la asignación ":=" que viene después encuentre el valor.
        gen.addToken(areaMax);

        RESULT = null; 
    :};